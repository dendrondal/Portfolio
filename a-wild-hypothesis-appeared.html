<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
  <meta charset="UTF-8" />
  <title>A Wild Hypothesis Appeared! | Dal&#39;s Portfolio</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="https://dalwilliams.info/static/m-dark.css" />
  <link rel="icon" href="https://dalwilliams.info/images/favicon.ico" type="image/x-ico" />
  <link rel="canonical" href="https://dalwilliams.info/a-wild-hypothesis-appeared.html" />
  <link href="https://dalwilliams.info/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Dal&#39;s Portfolio" />
  <link href="https://dalwilliams.info/feeds/blog.atom.xml" type="application/atom+xml" rel="alternate" title="Dal&#39;s Portfolio | Blog" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#353535" />
  <meta name="twitter:site" content="@dendrondal" />
  <meta property="og:site_name" content="Dal&#39;s Portfolio" />
  <meta property="og:title" content="A Wild Hypothesis Appeared!" />
  <meta name="twitter:title" content="A Wild Hypothesis Appeared!" />
  <meta property="og:url" content="https://dalwilliams.info/a-wild-hypothesis-appeared.html" />
  <meta property="og:description" content="Part 2 of the Wild Python series, focusing on property-based testing" />
  <meta name="twitter:description" content="Part 2 of the Wild Python series, focusing on property-based testing" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:type" content="article" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-166414162-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-166414162-1');
  </script>
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="https://dalwilliams.info/" id="m-navbar-brand" class="m-col-t-9 m-col-m-none m-left-m"><img src="https://dalwilliams.info/images/tree.jpg" alt="" />Dal&#39;s Portfolio</a>
      <a id="m-navbar-show" href="#navigation" title="Show navigation" class="m-col-t-3 m-hide-m m-text-right"></a>
      <a id="m-navbar-hide" href="#" title="Hide navigation" class="m-col-t-3 m-hide-m m-text-right"></a>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-12 m-col-m-none">
            <li><a href="https://dalwilliams.info/pages/about-me.html">About</a></li>
            <li><a href="https://github.com/dendrondal/Portfolio/raw/pelican_migration/content/pages/Williams_Dal_Resume.pdf">Resume</a></li>
            <li><a href="https://github.com/dendrondal">GitHub</a></li>
            <li><a href="https://linkedin.com/in/dal-williams">LinkedIn</a></li>
            <li><a href="https://twitter.com/dendrondal">Twitter</a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main>
<div class="m-container">
  <div class="m-row">
    <article class="m-col-m-10 m-nopadb">
      <header>
        <h1><a href="https://dalwilliams.info/a-wild-hypothesis-appeared.html" rel="bookmark" title="Permalink to A Wild Hypothesis Appeared!">
          <time class="m-date" datetime="2020-05-29T00:00:00-05:00">
            May <span class="m-date-day">29</span> 2020
          </time>
          A Wild Hypothesis Appeared!
        </a></h1>
      </header>
      <div class="m-clearfix-l"></div>
<!-- content -->
<aside class="m-note m-default">
<h3>This article presumes some familiarity with unit and functional testing, as well as pytest. Though there are many tutorials for these topics online, I found less on the Hypothesis library. Moreover, I wrote this article to gain some intuition as to <em>when</em> to use property-based tests rather than example-based tests.</h3>
</aside>
<section id="what-is-property-based-testing">
<h2>What is property-based testing?</h2>
<p>Putting it rather coarsely, property-based testing (PBT) is a method of brute forcing your tests. Rather than the general workflow of asserting what a function should output with a given example, PBT runs the function multiple times with inputs sampled from a space of all possible examples. You may be thinking &quot;why not just use <code>pytest.mark.parameterize</code>?&quot; The answer is edge cases and other unknown unknowns. In theory, this should catch bugs more quickly, and result in less code necessary for your test suite by not having to manually add pytest marks.</p>
<p><img alt="image0" src="https://1.bp.blogspot.com/-5n5lQoNvzNU/XAT3u9uu8SI/AAAAAAAAhUo/OMOOhkSYKNMAXaGeW0MfF07uudCWa-HZwCLcBGAs/s1600/everyone.png" style="width: 400px" /></p>
<p>The introduction to <a href="https://hypothesis.works/articles/getting-started-with-hypothesis/">Hypothesis</a>, a PBT framework for Python, gives a quick rundown of what this might look like. Hypothesis is effectively the Python version of <a href="https://www.youtube.com/watch?v=hXnS_Xjwk2Y">QuickCheck</a>, Haskell's PBT framework. Functional programming languages like Haskell lend themselves well to PBT, due to their heavily mathematical nature. Going through some <a href="https://dev.to/jdsteinhauser/intro-to-property-based-testing-2cj8">properties of mathematical funcitons</a>, their Python equivalents would look something like this:</p>
<pre class="m-code"><span class="c1"># Associative: a + (b + c) = (a + b) + c</span>
<span class="k">assert</span> <span class="n">lst1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst3</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">lst1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst2</span><span class="p">))</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst3</span><span class="p">)</span>
<span class="c1"># Commutative: a + b = b + a</span>
<span class="k">assert</span> <span class="nb">max</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="nb">max</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="c1"># Distributive: a(b+c) = ab + ac</span>
<span class="k">assert</span> <span class="s1">&#39;asdf&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;jkl;&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;asdf&#39;</span> <span class="o">+</span> <span class="s1">&#39;jkl;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="c1"># Idiompotent: f(x) = f(f(x))</span>
<span class="n">lst1</span> <span class="o">=</span> <span class="n">lst</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">lst2</span> <span class="o">=</span> <span class="n">lst</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">lst1</span> <span class="o">==</span> <span class="n">lst2</span>
<span class="c1"># Identity: f(x, i) = x</span>
<span class="k">assert</span> <span class="n">lst</span><span class="o">.</span><span class="n">extend</span><span class="p">([])</span> <span class="o">==</span> <span class="n">lst</span>
<span class="c1"># &#39;Bilbo&#39; testing (there and back again)</span>
<span class="k">assert</span> <span class="n">lst1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">lst</span>
<span class="c1"># No surprise side effects</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></pre>
<p>These are contrived examples, but they should give you some sort of an idea of what the &quot;property&quot; in PBT implies. I originally referred to PBT as brute forcing your tests, but that's only partially true. A good framework, like Hypothesis, will change behavior once an assertion fails, and &quot;shrink&quot; the input it provides until it can provide a <em>minimum working example</em> of what will cause your program to break. This save a lot of guesswork in diagnosing the problem.</p>
</section>
<section id="hypothesis-in-action">
<h2>Hypothesis in Action</h2>
<p>At its core, Hypothesis builds its test suite around strategies (the <code>st</code> module from here on). These allow for random generation of data types within Python, and allow for parameterization (i.e. an ASCII string with a minimum length of 1). For more complex data types, <code>st.composite</code> can be used. Other important terms are <code>given</code> and <code>assume</code>. The <code>&#64;given</code> decorator is used to express which strategies and boundaries a function should be tested with, and <code>assume</code> removes test cases that we don't care about. The opposite of assume, <code>&#64;example</code>, tells hypothesis to try this test case every single time. A good place for this would be to include a SQL injection attack as an example when testing a Flask function that has a query string.</p>
<p>Before going into production use cases, let's take one of our contrived unit tests from the previous section and change it to a Hypothesis test. Let's say we're writing our own programming language, and want to make sure our version of Python's <code>upper</code> method work properly. This is an ideal use case for PBT, as we want to make sure this can handle any kind of text:</p>
<pre class="m-code"><span class="nd">@given</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="c1"># Idiompotency</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="c1"># Distributive (this assumes + is overloaded for string concatenation)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="c1"># No side effects</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></pre>
<p>This is where hypothesis gets its name from, as we could write out the above test like a traditional hypothesis: &quot;Given a string of length &gt; 1, upper will be idiompotent, distributive, and will return a string with the same length as its input.&quot; Then we test it by trying to find a case that falsifies that hypothesis. If we were wanting to extend our new language's functionality by using the <code>extend</code> method (see what I did there?), we would need a more complex data type to test on. This is where composite strategies come in:</p>
<pre class="m-code"><span class="nd">@st</span><span class="o">.</span><span class="n">composite</span>
<span class="k">def</span> <span class="nf">make_lists</span><span class="p">(</span><span class="n">draw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">draw</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">lists</span><span class="p">(</span><span class="n">from_type</span><span class="p">(),</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">make_lists</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_extend</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">assume</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span><span class="p">,</span> <span class="n">lst3</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">concat</span> <span class="o">=</span> <span class="n">lst1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst3</span><span class="p">))</span>
    <span class="c1"># Associativity</span>
    <span class="k">assert</span> <span class="n">concat</span> <span class="o">==</span> <span class="p">(</span><span class="n">lst1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst2</span><span class="p">))</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lst3</span><span class="p">)</span>
    <span class="c1"># No side effects</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">concat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span></pre>
<p>Here we draw 3 lists full of arbitrary data types and lengths with <code>make_lists</code>, and try to combine them. As a fail-safe, we assume that all three lists exist.Not to belabor the point, I will recommend the <a href="https://hypothesis.readthedocs.io/en/latest/data.html">documentation</a> for more examples, and move on to production use cases.</p>
</section>
<section id="hypothesis-in-the-wild">
<h2>Hypothesis in the Wild</h2>
<p>The <a href="https://github.com/KissPeter/APIFuzzer">APIFuzzer</a> library uses Hypothesis to see if their API testing framework can handle arbitrary JSON. This is trivial to implement in Hypothesis:</p>
<pre class="m-code"><span class="nd">@st</span><span class="o">.</span><span class="n">composite</span>
<span class="k">def</span> <span class="nf">dict_str</span><span class="p">(</span><span class="n">draw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">draw</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">dictionaries</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="nd">@st</span><span class="o">.</span><span class="n">composite</span>
<span class="k">def</span> <span class="nf">list_of_dicts</span><span class="p">(</span><span class="n">draw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">draw</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">lists</span><span class="p">(</span><span class="n">dict_str</span><span class="p">()))</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dict_str</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_json_data_dict_valid</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">json_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">list_of_dicts</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_json_data_list_valid</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">json_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span></pre>
<p>Walking through this code, the composite used draws from strategies, producing nonzero sized dictionaries with string keys and values. It can then produce lists of these dicts by drawing from this strategy. It's then used to make sure their <code>json_data</code> function returns the proper type regardless of what is thrown at it. The Hypothesis documentation has an <a href="https://hypothesis.readthedocs.io/en/latest/data.html#recursive-data">even more robust</a> example of generating random JSON by using a recursive strategy. This method uses unbounded types, but we can also add boundary conditions based off of what input sizes/shapes we expect. Here's an example from <a href="https://github.com/pyvista/pyvista">pyvista</a>, a 3D rendering library, where they want to make sure an error is raised when someone tries to use their <code>grid.transform</code> method is called on an improperly shaped array:</p>
<pre class="m-code"><span class="nd">@given</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">arrays</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">array_shapes</span><span class="p">(</span><span class="n">max_dims</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_side</span><span class="o">=</span><span class="mi">5</span><span class="p">)))</span>
<span class="k">def</span> <span class="nf">test_transform_should_fail_given_wrong_numpy_shape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
    <span class="n">assume</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">array</span><span class="p">)</span></pre>
<p>Let's move on to something that many data scientists will want to keep in mind, which is determining whether the output of a function is stochastic or deterministic. The <a href="https://github.com/Axelrod-Python/Axelrod">Axelrod</a> library, a game theory simulator in python, does just this with Hypothesis. Here, they test to see if either randomizing the choices of their players at the start by using a <code>Random</code> player or making the decision making of the players less consistent by adding noise.</p>
<pre class="m-code"><span class="nd">@given</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">floats</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>

    <span class="n">assume</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">axl</span><span class="o">.</span><span class="n">Cooperator</span><span class="p">(),</span> <span class="n">axl</span><span class="o">.</span><span class="n">Cooperator</span><span class="p">()</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">axl</span><span class="o">.</span><span class="n">Match</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">_stochastic</span><span class="p">)</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">axl</span><span class="o">.</span><span class="n">Match</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">_stochastic</span><span class="p">)</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">axl</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">axl</span><span class="o">.</span><span class="n">Match</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">_stochastic</span><span class="p">)</span></pre>
<p>As you can imagine, this pattern would be ideal to test a bootstrapping or test-train splitting function. Hypothesis also lets you set the seed for the randomization, helping you ensure reproducibility.</p>
</section>
<section id="extensibility">
<h2>Extensibility</h2>
<p>Hypothesis also has built-in modules for Numpy (<code>hynp</code> below) and Pandas compatibility. Here is a test within Numpy itself that makes sure array printing works with all possible unicode strings:</p>
<pre class="m-code"><span class="nd">@given</span><span class="p">(</span><span class="n">hynp</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)))</span>
<span class="k">def</span> <span class="nf">test_any_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="c1"># This test checks that, given any value that can be represented in an</span>
    <span class="c1"># array of dtype(&quot;U&quot;) (i.e. unicode string), ...</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">text</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">text</span><span class="p">])</span>
    <span class="c1"># casting a list of them to an array does not e.g. truncate the value</span>
    <span class="n">assert_equal</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">text</span><span class="p">)</span>
    <span class="c1"># and that np.array2string puts a newline in the expected location</span>
    <span class="n">expected_repr</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">{0!r}</span><span class="s2"> </span><span class="si">{0!r}</span><span class="se">\n</span><span class="s2"> </span><span class="si">{0!r}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">text</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">assert_equal</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expected_repr</span><span class="p">)</span></pre>
<p>As for Pandas, I'll use an example from my <a href="https://github.com/dendrondal/Localvore">Localvore</a> project. I had a function, <code>filter_predictions</code>, that was the core of an ETL pipeline. At a high level, it ingested a dataframe of JSON data of recipes (e.g. {'text': '1 cup flour'}) along with ids and matching model predicitons, and produced another dataframe with ids and ingredient lists (minus adjectives and units, e.g. 'flour'). Given that this was the major bottleneck in my ETL pipeline, I wanted to make sure any errors were caught early. Rather than using a mock DataFrame, I instead decided to let Hypothesis do the heavy lifting for me:</p>
<pre class="m-code"><span class="nd">@given</span><span class="p">(</span>
    <span class="n">data_frames</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
            <span class="n">column</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span>
                <span class="n">elements</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                <span class="n">alphabet</span><span class="o">=</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">column</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;raw_ingrs&#39;</span><span class="p">,</span>
                <span class="n">elements</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">lists</span><span class="p">(</span>
                    <span class="n">st</span><span class="o">.</span><span class="n">dictionaries</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">just</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">),</span>
                                    <span class="n">values</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                                    <span class="n">alphabet</span><span class="o">=</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">),</span>
                                    <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="n">min_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">list</span>
            <span class="p">),</span>
            <span class="n">column</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">,</span>
                <span class="n">elements</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">booleans</span><span class="p">(),</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">list</span>
            <span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_filter_predictions</span><span class="p">(</span><span class="n">mock_df</span><span class="p">):</span>
    <span class="n">assume</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mock_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">assume</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mock_df</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">ETL_pipeline</span><span class="o">.</span><span class="n">filter_predictions</span><span class="p">(</span><span class="n">mock_df</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;ingredients&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;ingredients&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span></pre>
<p>The <code>data_frames</code> utility can define a set of columns, with names and strategies for each column. I'm also making the assumptions that the dataframe is non-empty, and has the proper number of columns. Note the versatility of strategies available here: one can choose the alphabet to draw from, can create a list of booleans, and can fix a certain value, such as all dictionaries having the 'text' key. This may be a lot of code, but it allows me to be very confident in the code that I write. In addition, I could reuse this mock dataframe strategy by putting it in a function with the <code>composite</code> decorator.</p>
</section>
<section id="when-not-to-use-hypothesis">
<h2>When <em>Not</em> to use Hypothesis</h2>
<p>Some advice from the Hypothesis documentation gives some good starting wisdom: if you find that you need to parameterize a test extensively, that is a good sight PBT may be effective there. The primary reasons I have found not to use PBT is when either properties are very difficult to think of, or when they add too much overhead to your CI/CD pipeline (the default number of function calls for each Hypothesis test is 200). Between this increase in runtime, mental overhead, and code, PBT should not be your go-to method of testing, but instead a tool in your toolbox. The key factor in deciding what type of test to use isn't necessarily the complexity of your function, but <em>how many different types of input</em> are valid for said function. PBT can also be useful when approaching large legacy codebases. As a particular example, <a href="https://medium.com/criteo-labs/introduction-to-property-based-testing-f5236229d237">this article</a> about PBT in JavaScript managed to find a bug in a 1 million download/day package by treating a certain function as a black box, and making assumptions from there.</p>
<p>I hope this introduction was helpful to all reading it. My challenge to you is to find a test you've written for a function with many possible input types, and try a property based test there. Let me know how it goes!</p>
</section>
<!-- /content -->
      <footer>
        <p>Posted by <a href="https://dalwilliams.info/author/jon-steven-dal-williams.html">Jon Steven Dal Williams</a> on <time datetime="2020-05-29T00:00:00-05:00">Fri 29 May 2020</time> in <a href="https://dalwilliams.info/category/blog.html">Blog</a>. Tags: <a href="https://dalwilliams.info/tag/wild-python.html">wild python</a>, <a href="https://dalwilliams.info/tag/testing.html">testing</a>, <a href="https://dalwilliams.info/tag/tutorials.html">tutorials</a>, <a href="https://dalwilliams.info/tag/functional-programming.html">functional programming</a>.</p>
      </footer>
    </article>
    <nav class="m-navpanel m-col-m-2">
      <h3>Categories</h3>
      <ol class="m-block-bar-m">
        <li><a href="https://dalwilliams.info/category/blog.html">Blog</a></li>
        <li><a href="https://dalwilliams.info/category/projects.html">projects</a></li>
        <li><a href="https://dalwilliams.info/category/talks.html">talks</a></li>
        <li><a href="https://dalwilliams.info/category/tutorial.html">tutorial</a></li>
        <li><a href="https://dalwilliams.info/category/tutorials.html">Tutorials</a></li>
      </ol>
      <h3>Tag cloud</h3>
      <ul class="m-tagcloud">
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/airflow.html">Airflow</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/altair.html">Altair</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/aws.html">AWS</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/bash.html">Bash</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/bayesian-stats.html">Bayesian stats</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/chatbots.html">chatbots</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/chemistry.html">chemistry</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/cicd.html">CI/CD</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/cnns.html">CNNs</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/computer-vision.html">Computer Vision</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/css.html">CSS</a></li>
        <li class="m-tag-4"><a href="https://dalwilliams.info/tag/docker.html">Docker</a></li>
        <li class="m-tag-5"><a href="https://dalwilliams.info/tag/flask.html">Flask</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/functional-programming.html">functional programming</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/gans.html">GANs</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/git.html">Git</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/jinja.html">Jinja</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/jupyter.html">Jupyter</a></li>
        <li class="m-tag-4"><a href="https://dalwilliams.info/tag/keras.html">Keras</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/latex.html">LaTeX</a></li>
        <li class="m-tag-5"><a href="https://dalwilliams.info/tag/linux.html">Linux</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/luigi.html">Luigi</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/make.html">Make</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/markdown.html">Markdown</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/microsoft.html">Microsoft</a></li>
        <li class="m-tag-4"><a href="https://dalwilliams.info/tag/mission-driven-data-science.html">Mission-driven data science</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/mongodb.html">MongoDB</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/pandas.html">Pandas</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/papermill.html">Papermill</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/pelican.html">Pelican</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/pipx.html">pipx</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/poetry.html">Poetry</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/productivity.html">Productivity</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/pytorch.html">PyTorch</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/reproducibility.html">reproducibility</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/rest.html">REST</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/rst.html">rST</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/science-writing.html">Science Writing</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/scientific-python.html">Scientific Python</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/scikit-learn.html">SciKit Learn</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/spacy.html">Spacy</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/sqalchemy.html">SQAlchemy</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/sqlite.html">SQLite</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/swagger.html">Swagger</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/tensorflow.html">TensorFlow</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/testing.html">testing</a></li>
        <li class="m-tag-4"><a href="https://dalwilliams.info/tag/tutorials.html">tutorials</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/vaes.html">VAEs</a></li>
        <li class="m-tag-2"><a href="https://dalwilliams.info/tag/vim.html">Vim</a></li>
        <li class="m-tag-3"><a href="https://dalwilliams.info/tag/wild-python.html">wild python</a></li>
      </ul>
    </nav>
  </div>
</div>
</main>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Dal's Portfolio. Powered by <a href="https://getpelican.com">Pelican</a> and <a href="https://mcss.mosra.cz">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>